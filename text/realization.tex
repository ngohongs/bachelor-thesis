\chapter{Návrh aplikace}
Tato kapitola se věnuje kromě návrhu simulátoru vodního povrchu a jeho další optických vlastností, také i strukuře aplikace testovací scény. Nejdříve je zmíněn celkový pohled na aplikaci, ve kterém jsou zohledněné procesy zvolených algoritmů pro zobrazení scény, z kterých následně vychází struktura simulátoru a aplikace.

    \section{Procesy simulátoru a aplikace testovací scény}
        
        Hlavním algoritmem simulace bude Müllerova metoda \cite{Mueller2008} simulace vodního povrchu podle vlnové rovnice. Metoda je založena na redukci 3D prostoru vody na 2D prostor. K její implemetanci bude třeba předávat dvě 2D pole, které drží informace o výšce hladiny a rychlosti vlnění, mezi paměti aplikační částí a paměti grafické karty. Pole s výškami hladiny v jednotlivých bodech vodní roviny bude dále nutným vstupem pro aplikaci optických vlasností vody, kokrétněji k výpočetu povrchových normál. Obyčejná datová sturkutra pole ale nelze mezi pamětí aplikace a pamětí grafiky jednoduše předávat, řeším toho problému bude předávání textur, které mohou mít v grafických kartách podobu polí.   
        
        Po provedeném výpočtu výšek hladiny z vlnové rovnice lze dále provést simulaci optických vlastností. Před vykreslení refrakcí bude třeba promítnout kaustiky na přijímací objekty, tj. objekty pod hladinou vody, neboť refrakce zkreslují obraz pod vodou a to včetně kaustik. Shahovo metoda formace kaustik \cite{Shah2007} výpočítává mapu kaustik pomocí textury pozic a normál jednotlivých vrcholů vodního povrchu a textury pozic vrcholů objektů, na které se kaustiky mohou promítnou. Mapa bude obdobně ve formátu textury.
        
        Reflekace a refrakce lze vykreslit stejným algoritmem, neboť principiálně fungují podobně. Jedna varianta využívá pro vzorkování barvy a světla odražený paprsek od povrchu vody, zatímco druhá varianta počítá s lomeným paprskem. Odhad průsečíků pohledových paprsků se scénou  bude implementován stejně jako u Shahovy metody mapování kaustik \cite{Shah2007}, která příjímá na vstupu texturu s pozicemi vrcholů objektů, vůči kterým se mají průsečíky počítat. 
        
        Všechny informace v jednotlivých fázích simulace vodního povrchu se následně předají konečnému programu, které data zapracuje pro vykreslení finální podoby scény. Celá vykreslovací smyčka je znázorněna v diagramu \ref{fig:process}.
        
        \begin{figure}\centering
            \includegraphics[width=\textwidth]{img/process}
            \caption{Diagram procesů simulátoru a aplikace testovací scény.}
            \label{fig:process}
        \end{figure}
        
    \section{Strukutra simulátoru a aplikace testovací scény}
        
        Z diagramu procesů \ref{fig:process} je paterné i struktura programu. Simulátor vodního útvaru může být rozdělen na dílčí části. Aplikační část programu bude provádeět jen finální vykreslení a zpracování vstup od uživatele programu. Tyto procesy simulátoru a aplikace zachycují následující třídy znázorněné v UML diagramu tříd \ref{fig:class}.
        
        \begin{figure}\centering
            \includegraphics[width=\textwidth]{img/class}
            \caption{Diagram tříd simulátoru a aplikace testovací scény.}
            \label{fig:class}
        \end{figure}
        
        \subsection{Třída Application}
        
            Třída \verb|Application| po zavolání funkce \verb|Run| zahájí inicializaci ostatní tříd a začné provádět vykreslovací smyčku. Ve smyčce bude volat jednotlivé fáze simulace jako simulace vodního povrchu pomocí vlnové rovnice, která je reprezentována třídou \verb|SimulationRenderer|, výpočet mapy kaustik reprezentována třídou \verb|CausticsRenderer| a vykreslení reflekcí, refrakcí nebo finalní scény třídou \verb|SceneRenderer|. 
            
        \subsection{Třída State}
            
            Třída \verb|State| bude zprostředkovávát všechny informace mezi třídami \verb|CausticsRenderer|, \verb|SceneRenderer|,  \verb|SimulationRenderer| a \verb|Application|. Mezivýsledky simulace, které budou ve formátu textur, se ve třídě \verb|State| budou ukládát a budou následně přístupné všem ostatním třídám k použití. 
            
        \subsection{Třída SimulationRenderer}
            
            \verb|SimulationRenderer| bude provádět po zavolání funkce \verb|Render|  výpočet vlnové rovnice \cite{Mueller2008}. Následně bude  ukládat výšku a rychlost vlnění vodní hladiny do textury \verb|m_HeightField| ve třidě \verb|State|, aby ji v dalších fázích mohli přijmout jako vstupní parameter, např. pro třídu \verb|CausticsRenderer| pro výpočet kaustik.
            
            
        \subsection{Třída CausticsRenderer}
        
            Třída \verb|CausticsRenderer| pomocí výškové mapy \verb|m_HeightField| bude vykreslovat podpůrné textury podle Shahovy metody \cite{Shah2007}. Nejdříve vykreslí texturu pozic a normál vrcholů refraktujícího objektu, tj. vodní hladiny. Poté vykreslí pozice vrcholů objektů, na které se kaustiky mohou promíntou. S těmito podpůrnými daty bude následně možné vypočítat mapu kaustik. Pro další fázi simulace bude mapa kaustik uložena ve třidě \verb|State| jako \verb|m_CausticMap|.
            
        \subsection{Třída SceneRenderer}
        
            Konečná fáze simulace bude vykreslení finální scény. Reflekce a refrakce budou zde též naimplenotané, neboť pro její vykreslení bude  třeba stejných algoritmů jako pro vykreslení finalní scény. 
            
            Refrakce a reflekce jsem se rozhodl naimplenotovat pomocí Shahova odhadu průsečíků \cite{Shah2007}. Po vypočtení průsečíku lomeného, resp. odrazeného, paprsku s geometrií scény v prostoru obrazu převedu souřadnice průsečíku do souřadnicového systému textur. V případě, že převedé souřadnice textury nebudou ležet v prostoru obrazovky, budu vzokrovat barvu pro daný paprsek podle textury prostředí uložené ve formátu \emph{cubemapy}. V případe, že bude ležet v prostoru obrazovky, budu vzorkovat barvu z obrazu scény.
            
            Útlum světla pod vodní hladinou budu implementovat podle vzdálenosti daného vrcholu od klidové hladiny vody. Podle vzdálenosti budu měnit barvu světla podle předem nastavených barev. Blízko hladiny nebude barva světla téměř modifikována, zatímco v hlubších prosterech vody  bude barva postupně přecházet na tmavě modrou. 
            
            Nakonec lze vykreslit finalní scénu. Všechny předešle fáze a operace se následně budou neustále opakovat ve vykreslovací smyčce.
            
            
\chapter{Implementace aplikace}
    Tato kapitola se zaobírá implementací simulátoru vodního útvaru. Protože aplikační část řídí jen nepodstatné části celého programu (zobrazení finalní scény, zpracování vstupu nebo předávání instrukcí grafické kartě), bude hlavním obsahem implementace \emph{shader} programů, které v realitě provádí všechny postatné operace algoritmů simulace.
    
    \section{Simulace hladiny podle vlnové rovnice}
        Simulace hladiny podle vlnové rovnice spočívá v tranformaci výšek jednotlivých bodů roviny. Samozřejmě je možné simulátoru rovinu dodat jako model (ve formátu .obj), lze ale také její geometrii procedulárně vygenerovat, což umožňuje větší kontrolu nad detailnosti vodní plochy zvyšováním rozlišení roviny (počtu vrcholů podél strany roviny). Třída \verb|PlaneGenerator| takovou rovinu generuje, geometrie roviny je generátorem normalizovaná, tj. souřadnice jeho vrcholů jsou škálovány do intervalu $[-1,1]$, dále vypočítá vrcholům jejich příslušnou texturovací souřadnici, které budou v simulaci důležitým vstupem. 
        
        \begin{verbatim}
void PlaneGenerator::Generate(const int & res,
    std::vector<Vertex>& vert, std::vector<unsigned int>& ind)
        \end{verbatim}
        
        Metoda \verb|Generate| podle rozlišení \verb|res|, tj. počet vrcholů podél strany roviny, generuje vrcholy roviny, které uloží do pole \verb|vert|, indexy vrcholů tvořící trojúhelníky, které jsou potřeba pro vykreslení roviny grafickým API OpenGL, jsou dále uloženy v poli \verb|ind|. Výsledná rovina je znázorněna v obrázku \ref{fig:plane}.        
        
        \begin{figure}\centering
            \includegraphics[width=0.5\textwidth]{img/plane}
            \caption{Vrcholy vygenerované gemeotrie roviny. \cite{Heightfield2022}}
            \label{fig:plane}
        \end{figure}
        
        Jak bylo v předešlých kapitolách zmíněno pro implementaci výpočtu simulace hladiny podle vlnové rovnice je třeba průběžně ukládat výšky  roviny a rychlost změny výšky v daném bodu roviny v polích \verb|u[i,j]| a \verb|v[i,j]|. Bohužel pole nelze jednoduše předávat mezi pamětí aplikace a paměti grafické karty. Řešením je použití textur. Jednotlivé pixely textury následně reprezentují jednu buňku pole. Protože textury pracují v kanálech RGB, lze zakompnovat pole \verb|u[i,j]| a \verb|v[i,j]| do jedné textury. Výšky budou uloženy v kanálu červené barvy, zatímco rychlost bude uložena v kanálu zelené barvy. Dále je dobré zmínit, že obvykle pracuje s nezápornými desitinými hodnota. Výpočty vlnové rovnice se ale mohou pohybovat v záporných hodnotách. Pro nastavení použití i těchto hodnot je třeba vygenerovat texturu s parametrem \verb|RGBA32F| místo \verb|RGBA|,
        
        \begin{verbatim}
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, m_Width, m_Height, 0,
             GL_RGB, GL_FLOAT, 0).
        \end{verbatim}

        Vzorkování mimo rozsah textury je nastaveno, jak Müller navrhoval, opakování hraničních hodnot nastavením parametru \verb|GL_CLAMP_TO_EDGE|
        
        \begin{verbatim}
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
                GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
                GL_CLAMP_TO_EDGE).
        \end{verbatim}

        Další překážkou je, že do textur nelze přistupovat a zároveň zapisovat, a proto je třeba vytvořit dvě textury simulace hladiny a během simulace mezi nimi prohazovat tzv. metodou ping-pongování. Nechť první textura je označena \verb|T_1| a druhá \verb|T_2|. Ping-pongování textury funguje následujícím způsobem, při prvním průchod \verb|i=0| vykreslovací smyčky bude simulátoru hladiny přiřazena textura \verb|T_1| jako vstupní parametr, z kterých výpočte stav vodní hladiny do dalšího průchodu smyčky, výsledek výpočtu následně uloží do textury \verb|T_2|. V dalším průchodu smyčky $i=1$ se prohodí textury \verb|T_1| a \verb|T_2|. Nyní bude textura \verb|T_2| vstupem simulátoru a \verb|T_1| odchozí texturou. Tento proces se neustále opakuje.
        \newpage
        Výpočet vlnové rovnice je znázorněn tímto kódem \emph{fragment shaderu}
        
        \begin{verbatim}
void main()
{
    if (abort) {
        FragColor = vec4(vec3(0.0), 1.0);
        return;
    }

    vec4 old_info = texture(heightField, fTexCoord);
    
    ...
    
    float vpdx = texture(heightField, pdx).r + AddDrop(pdx);
    float vndx = texture(heightField, ndx).r + AddDrop(ndx);
    float vpdy = texture(heightField, pdy).r + AddDrop(pdy);
    float vndy = texture(heightField, ndy).r + AddDrop(ndy);

    float nsum = vpdx + vndx + vpdy + vndy;
    float average =  (vpdx + vndx + vpdy + vndy) / 4.0;
    float h = texelSize;
    float old_u = old_info.r + AddDrop(fTexCoord);
    float old_v = old_info.g;

    float offset = average - old_u;
    float maxslope = waveSlope;
    float maxoffset = maxslope * h;

    if (offset > maxoffset) 
        old_u = old_u + offset - maxoffset;
    if (offset < -maxoffset)
        old_u = old_u + offset + maxoffset;
    
    float c = max(waveSpeed, 0.001f);
    float f = c * c * (nsum - 4 * old_u) / (h * h);
    float new_v = old_v + f * deltaTime;
    new_v = new_v - old_u;
    new_v = max((1 - waveDamping), 0.001f) * new_v;
    float new_u = old_u + new_v * deltaTime; 
    new_u = new_u;
    
    vec4 new_info = vec4(new_u , new_v, 0, 1);
    FragColor = new_info;
}.
        \end{verbatim}

        Hodnota \verb|abort| je pravdivá v případě, že bylo nařizeno textury výškové mapy vynulovat, a tím pádem i resetovat hladinu do klidového stavu. Funkce \verb|AddDrop| provádí deformaci hladiny uživatelem, která připíše podle dané pozice výšku okolním bodům ve tvaru sinusoidy.
        
        \begin{verbatim}
float AddDrop(vec2 pos)
{
    if (!drop)
        return 0.0;
    float r = max(radius, 0.001f)  * texelSize;
    float val = max(0.0, 1.0 - length(dropPos - pos) / r);
    val = 0.5 - cos(val * PI) * 0.5;
    return amplitude * val;
}         
        \end{verbatim}

        Müllerův uvedený algoritmus \cite{Mueller2008}, ale posouvá výšku  klidové roviny ve směru deformace. Jestli se za hladinu \uv{zatáhne} nahoru, posune celá hladina nahoru, což ale v realitě není možné. Wallace \cite{Wallace2022} řeší tento problém úpravou rychlosti výškou, tak aby změněná výška konvergovala k výšce klidové hladiny
        
        \begin{verbatim}
new_v = new_v - old_u.
        \end{verbatim}
        
        Zbylý program je dále podle Müllerova algoritmu \cite{Mueller2008} zmíněný v analýze metody podle vlnové rovnice. Deformovaná rovina, tj. vodní hladina, je následně zobrazena podle \emph{vertex shaderu}, který na vstupu příjímá textury výškové mapy a podle jeho texturovací souřadnice přičte k výšce vrcholu hodnotu textury uložené v červeném kanálu
        
        \begin{verbatim}
float height = texture(heightField, aTexCoord).r;
vec3 offset = vec3(0.0f, height, 0.0f);

vec4 worldCoord = model * vec4(aPosition + offset, 1.0f).
        \end{verbatim}

    \section{Simulace kaustik}
        Shahova formace kaustik \cite{Shah2007} předpokládá na vstupu tři podpůrné textury. Jedna obsahuje pozice ve a normály interpolavaných vrcholů ve světovém souřadnicovém systému vodního povrchu z pohledu světla , tzn. RGB barva objektu v textuře bude XYZ souřadnice pozice nebo normály. 
        
         \begin{figure}\centering
            \includegraphics[width=0.5\textwidth]{img/positions}
            \caption{Textura souřadnic interpolovaných vrcholů modelů scény z pohledu kamery.}
            \label{fig:positionstex}
        \end{figure}
        
        Normály hladiny, ale nemáme ihned k dispozici, neboť máme jen informace o výšce jednotlivých bodů roviny uložené ve výškové mapě. Naštěstí lze její hodnotu z výškové mapy vypočítat jako vektorový součin horizontální a vertikálních rozdílů výšek.  Nechť je $m$ výška vrcholu, pro který počítáme normálu, a $t$, $b$, $l$ a $r$ jsou výšky horního, dolního, levého a právého sousedního vrcholu $m$. Normála poté je rovna hodnotě $n$ \cite{Normal2022}
        
        \begin{equation}
            \begin{split}
            v &= (2, r - l, 0) \\
            h &= (0, t - b, 2) \\ 
            n &= v \times h. 
            \end{split}
        \end{equation}

        \noindent Dále bude třeba vyrenderovat pozice ve světové souřadnicovém systému objektů, na které mohou kaustiky promítnout.

        Kromě textur je třeba vygenerovat mřížku podobné v obrázku \ref{fig:plane}. Na rozdíl od mřížky používané v simulaci vodní hladiny je tato mřížka bez jakýkoliv hran, které vrcholy spojují. Ve výsledku má mřížka podobu rovnoněměrně rozložených vrcholů. Třída \verb|PlaneGenerator| pro výpočet kaustik umí vygenerovat požadovanou mřížku vygenerovat ve zvoleném rozlišení.
        
        \emph{Vertex shader}, který provadí většinu výpočtu kaustik, poté příjímá podpůrné textury zmíněné výše a mřížku, která má stejné rozlišení jako podpůrné textury, aby jednotlivému bodu mřížky odpovídal právě jeden texelu. Celý výpočet se řídí podle tohoto kódu
        
        \begin{verbatim}
void main()
{
    vec4 refractivePosition = texture(refractivePositions,
                                      aTexCoord);
    vec4 refractiveNormal = texture(refractiveNormals,
                                    aTexCoord);
    vec3 incidentLight = normalize(light.dir);
    vec3 refractedLight  = normalize(refract(incidentLight,
        normalize(refractiveNormal.xyz), ETA));
    vec4 p = EstimateIntersection(refractivePosition.xyz,
                                  refractedLight);
    if (refractivePosition.a <= 0.001f || 
        refractiveNormal.a <= 0.001f || 
        p.a <= 0.001f ||
        p.y > refractivePosition.y || 
        dot(p.xyz - refractivePosition.xyz,
            refractedLight) < 0.01f)
        fValid = 0;
    else
        fValid = 1;

    fDistance = distance(p, refractivePosition);
    fPhi = dot(-incidentLight, normalize(refractiveNormal.xyz));
    gl_Position = projection * view * model * vec4(p.xyz, 1.0);
}.   
        \end{verbatim}

        Algoritmus funguje takovým způsob, že prochází všemi body mřížky, a jestli danému bodu odpovídá nějaký validní texel z textury pozic refraktujícího objektu, tj. vodní hladiny, odhadne podle funkce \verb|EstimateIntersection| používající postup navržený Shahem  souřadnice průsečíku pomocí textury pozic příjímacích objektů. 
        
        Následuje kontrola validity průsečíku. Nejprve se kontroluje, jestli vrcholu mřížky odpovídá vůbec nějaký vrchol vodní hladiny, dále jestli odhadovaný průsečík vůbec existuje a nakonec jestli neleží odhadovaný průsečík nad hladinou vody.
        
        Výraznost kaustiky je pak určena podle počtu vrcholů, které se promítnout na stejné místo. OpenGL ale standardně provadí test hloubky, a proto by se intenzita kaustik nezvyšovala s vyšší počtem vrcholů se stejným průsečíkem. Pro dosažení tohoto efektu je třeba povolit OpenGL míchání barev funkcemi
        
        \begin{verbatim}
            glEnable(GL_BLEND);
            glBlendFunc(GL_ONE, GL_ONE).
        \end{verbatim}
        
        Funkce \verb|glBlendFund(GL_ONE, GL_ONE)| nastavuje způsob míchání barev tak, aby se po vyslání fragmentu pro vykreslení barva sečetla s barvou, která leží na stejné pozici jako vyslaný fragment. Intezita kaustika je dále ve \emph{fragment shaderu} tlumena vzdáleností \verb|fDistance|, kterou promítný vrchol cestoval, a úhelem dopadu světla \verb|fPhi|. 

        Objekty nakonec vzorkují mapu kaustik texturovacími souřadnicemi spočítané transformací světových souřadnic vrcholů do souřadnicové systému obrazu světla
        
        \begin{verbatim}
vec2 calculateCausticsTexCoord()
{
    vec4 lightClip = orthogonal *
                     lightView *
                     model * vec4(aPosition, 1.0);
    vec2 texC = 0.5 * (lightClip.xy/lightClip.w) + 0.5;
    return texC;
}.
        \end{verbatim}
        
        Shah dále doporučuje rozmazání mapy kaustik \cite{Shah2007}, aby nešly vidět artefakty zbůsobené promítáním konečného počtu vrcholů. Použití obyčejného rozmazání se z mapy kaustik ztrácí vysoké frekvence, které nejvíce vizuálně atraktivní, a proto provádím rozmázání konvolucí s Gaussovským jádrem.   

         \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/causticmap}
            \caption{Nefiltrovaná mapa kaustik.}
        \end{figure}
        
         \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/causticmapfiltered}
            \caption{Mapa kaustik filtorvaná Gaussovým rozmazáním.}
        \end{figure}
    \section{Simulace reflekcí a refrakcí}

        Reflekce a refrakce jsou naimplenotované obdobně jako formace kaustik. Po vyslání pohledové paprsku a jeho tranformaci na lomený, resp. odražený, paprsek se spočítá jeho odhadovaný průsečík pomocí textury pozice interpolavaných vrcholů objektů, od kterých se může obraz refrakovat, resp. odrazit. Odhad je stejně implementován jako u kaustik s výjimkou délky prvního odhadu, který je škálován podle úhlu pohledu
        
        \begin{verbatim}
vec2 EstimateIntersection(vec3 v,
                          vec3 r,
                          vec3 normal,
                          sampler2D positions)
{
	vec3 p1 = v + firstGuess * 
                (1 - dot(normal, normalize(toCameraDir))) * r; 
	vec4 texPt = projection * view * vec4(p1, 1.0);
	vec2 texC = 0.5 * (texPt.xy/texPt.w) + 0.5;
	vec4 recPos = texture(positions, texC);
    if (recPos.a <= 0.0f)
        return vec2(-1.0f);
	float d = distance(v, recPos.xyz);
	vec3 p2 = v + d * r;
	texPt = projection * view * vec4(p2, 1.0);
	texC = 0.5 * (texPt.xy/texPt.w) + 0.5;
    if (texC.x < 0 || texC.x > 1 || texC.y < 0 || texC.y > 1)
        return vec2(-1.0f);
	return texC;
}.
         \end{verbatim}
    Hodnota \verb|v| zde značí bod, od kterého se lomený, resp. odražený, paprsek \verb|r| pohybuje dále. 
    
    Jestli hledaný průsečík neexistuje nebo texturovací souřadnice jsou mimo obraz displeje, vzorkují se reflekce a refrakce podle textury prostředí uložené jako \emph{cubemapa}. 
    
    Po získání texturovacích souřadnic se vzorkuje barva reflekcí a refrakcí podle pomocných textur, ve kterých je uložena scéna. Pro refrakce pomocná textura obsahuje vykreselené objekty, které leží pod hladinou vody, neboť se refrakcí zkreslují jen, co je pod její hladinou. U reflekcí jsou to naopak jen objekty, které leží nad hladinou.  
    
        
    \section{Simulace útlumu světla}
    
    Útlum světla je naivně naimplentován podle vzdálenosti objektů od hladiny vody. Podle vzdálenosti dále postupně přechází barva světla podle předem definovaných barev
    
    \begin{verbatim}
vec3 n = vec3(1.0f);
vec3 f = firstStageColor;
vec3 s = secondStageColor;
vec3 t = finalStageColor;

if (diff <= 0)
    lightColor = n;
else if (diff <= firstStage)
    lightColor = 
      mix(n, f, (diff - 0.0f)/(firstStage - 0.0f));
else if (diff <= secondStage)
    lightColor = 
      mix(f, s, (diff - firstStage)/(secondStage - firstStage));
else
    lightColor =
      mix(s, t, (diff - secondStage)/(3.0f - secondStage));

...

float a = attenuation;
float I = exp(-a * clamp(diff, 0, diff));
    \end{verbatim}

\chapter{Výsledky implementace}
    
    Následující kapitola je zaměřena na ukázku konečných vizuálních výsledků implementace. Mimo vykreslených scén jsou zde probrány nedostaky zvolených algoritmů.
   
    Největších chyb vzniká při aproximací velmi citlivých výpočtů jako refrakce a reflekce viditelný v obrázcích \ref{fig:rrerr1}, \ref{fig:rrerr2}, \ref{fig:rrerr3} \ref{fig:duckr}.
    
    V obrázku \ref{fig:rrerr1} dochází k tomu, že odhadovaný průsečík vychází z prostoru obrazu a následně místo textury scény vzorkuje z textury prostředí v \emph{cubemapě}. 
    
    V obrázku \ref{fig:rrerr2} dochází k tomu, že vyslaný lomený prvek protne scénu ale ve špatném místě, protože realný průsečík je z pohledu kamery schovaný za nějakou geometrií, která leží před ním.
    
    V obrázku \ref{fig:rrerr3} lze vidět chybu mezi míchání barvy odražené a refraktované scény podle Fresnelových ronvic způsobena nepřeností aproximací průsečíků. 
    
    Odraz kachničky v obrázku \ref{fig:duckr} má siluetu samotné kachničky kvůli způsobu odhadu průsečíku, který ověřuje jeho správnost pomocí textury pozic reflektovaných objektů (zde kachničky). 
    
    Tyto nedostatky jsou nejvíce výrazné při rovné vodní hladině. Naštětí se v realitě vodní hladinu neustále hýbe a díky zkreslení obrazu refrakcemi jsou tyto chyby zamaskovány. Korektnost výpočtu průsečíku spočívá ve správném odhadu délky lomeného, resp. odraženého paprsku. V aplikaci testovací scény lze tento parametr měnit v sekci \emph{Reflections/refractions settings} parameter \emph{First guess}.

    Dalších vizuální artefakty mohou nastat při volbě silné intezity kaustik (viz obrázek \ref{fig:causticerr}), které jsou způsobené  Shahovou metodou \cite{Shah2007}, která promítá jen konečný počet paprsků (vrcholů) na skrz vodní hladinu.
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr1}
        \caption{Chyba refrakcí způsobena špatným odhadem průsečíku a restrikcí odhadu na prostor obrazu.}
        \label{fig:rrerr1}
    \end{figure}
    
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr2}
        \caption{Chyba refrakcí způsobena schovaným průsečíkem za cizí geometrií.}
        \label{fig:rrerr2}
    \end{figure}
    
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr3}
        \caption{Chyba refrakcí a reflekcí způsobena nepřeností odhadu průsečíku.}
        \label{fig:rrerr3}
    \end{figure}
    
    
     \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/duckreflection}
        \caption{Odraz kachničky.}
     \label{fig:duckr}
    \end{figure}
    
    \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/heightfield}
            \caption{Testovací scéna se simulátorem vodního útvaru.}
    \end{figure}
    
    \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/normal}
            \caption{Testovací scéna s viditelnými kaustikami.}
    \end{figure}
        
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/caustics}
        \caption{Formace kaustik kaustik na podvodních objektech.}
    \end{figure}
    
     \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/causticserror}
        \caption{Artefakty mapy kaustik způsobené promítáním konečného počtu vrcholů}
        \label{fig:causticerr}
    \end{figure}
    
    
    
    
    
