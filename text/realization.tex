\chapter{Návrh aplikace}
Tato kapitola se věnuje kromě návrhu simulátoru vodního povrchu a jeho dalších optických vlastností, také i struktuře aplikace testovací scény. Nejdříve je zmíněn celkový pohled na aplikaci, ve kterém jsou zohledněné procesy zvolených algoritmů pro zobrazení scény, z kterých následně vychází struktura simulátoru a aplikace.

    \section{Procesy simulátoru a aplikace testovací scény}
        
        Hlavním algoritmem simulace bude Müllerova metoda \cite{Mueller2008} simulace vodního povrchu podle vlnové rovnice. Metoda je založena na redukci 3D prostoru vody na 2D prostor. K její implementaci bude třeba předávat dvě 2D pole, které drží informace o výšce hladiny a rychlosti vlnění, mezi pamětí aplikační částí a pamětí grafické karty. Pole s výškami hladiny v jednotlivých bodech vodní roviny bude dále nutným vstupem pro aplikaci optických vlastností vody, konkrétněji k výpočtu povrchových normál. Obyčejná datová struktura pole ale nelze mezi pamětí aplikace a pamětí grafiky jednoduše předávat, řešením toho problému bude předávání textur, které mohou mít v grafických kartách podobu polí.   
        
        Po provedeném výpočtu výšek hladiny z vlnové rovnice lze dále provést simulaci optických vlastností. Před vykreslení refrakcí bude třeba promítnout kaustiky na přijímací objekty, tj. objekty pod hladinou vody, neboť refrakce zkreslují obraz pod vodou a to včetně kaustik. Shahovo metoda formace kaustik \cite{Shah2007} vypočítává mapu kaustik pomocí textury pozic a normál jednotlivých vrcholů vodního povrchu a textury pozic vrcholů objektů, na které se kaustiky mohou promítnou. Mapa bude obdobně ve formátu textury.
        
        Reflekce a refrakce lze vykreslit stejným algoritmem, neboť principiálně fungují podobně. Jedna varianta využívá pro vzorkování barvy a světla odražený paprsek od povrchu vody, zatímco druhá varianta počítá s lomeným paprskem. Odhad průsečíků pohledových paprsků se scénou  bude implementován stejně jako u Shahovy metody mapování kaustik \cite{Shah2007}, která přijímá na vstupu texturu s pozicemi vrcholů objektů, vůči kterým se mají průsečíky počítat. 
        
        Všechny informace v jednotlivých fázích simulace vodního povrchu se následně předají konečnému programu, které data zpracuje pro vykreslení finální podoby scény. Celá vykreslovací smyčka je znázorněna v diagramu \ref{fig:process}.
        
        \begin{figure}\centering
            \includegraphics[width=\textwidth]{img/process}
            \caption{Diagram procesů simulátoru a aplikace testovací scény.}
            \label{fig:process}
        \end{figure}
        
    \section{Struktura simulátoru a aplikace testovací scény}
        
        Z diagramu procesů \ref{fig:process} je patrná i struktura programu. Simulátor vodního útvaru může být rozdělen na dílčí části. Aplikační část programu bude provádět jen finální vykreslení a zpracování vstupu od uživatele programu. Tyto procesy simulátoru a aplikace zachycují následující třídy znázorněné v UML diagramu tříd \ref{fig:class}.
        
        \begin{figure}\centering
            \includegraphics[width=\textwidth]{img/class}
            \caption{Diagram tříd simulátoru a aplikace testovací scény.}
            \label{fig:class}
        \end{figure}
        
        \subsection{Třída Application}
        
            Třída \verb|Application| po zavolání funkce \verb|Run| zahájí inicializaci ostatních tříd a začne provádět vykreslovací smyčku. Ve smyčce bude volat jednotlivé fáze simulace jako simulace vodního povrchu pomocí vlnové rovnice, která bude reprezentována třídou \verb|SimulationRenderer|, výpočet mapy kaustik reprezentována třídou \verb|CausticsRenderer| a vykreslení reflekcí, refrakcí nebo finální scény třídou \verb|SceneRenderer|. 
            
        \subsection{Třída State}
            
            Třída \verb|State| bude zprostředkovávat všechny informace mezi třídami provádějící simulaci a vykreslování  testovací scény \verb|CausticsRenderer|, \verb|SceneRenderer|, \verb|SimulationRenderer| a \verb|Application|. Mezivýsledky simulace, které budou ve formátu textur, se ve třídě \verb|State| budou ukládat a budou následně přístupné všem ostatním třídám k použití. 
            
        \subsection{Třída SimulationRenderer}
            
            \verb|SimulationRenderer| bude provádět po zavolání funkce \verb|Render|  výpočet vlnové rovnice \cite{Mueller2008}. Následně bude  ukládat výšku a rychlost vlnění vodní hladiny do textury \verb|m_HeightField| ve třídě \verb|State|, aby ji v dalších fázích mohli přijmout jako vstupní parametr, např. třída \verb|CausticsRenderer| pro výpočet kaustik.
            
            
        \subsection{Třída CausticsRenderer}
        
            Třída \verb|CausticsRenderer| pomocí výškové mapy \verb|m_HeightField| bude vykreslovat podpůrné textury podle Shahovy metody \cite{Shah2007}. Nejdříve vykreslí texturu pozic a normál vrcholů refraktujícího objektu, tj. vodní hladiny. Poté vykreslí pozice vrcholů objektů, na které se kaustiky mohou promítnou. S těmito podpůrnými daty bude následně možné vypočítat mapu kaustik. Pro další fázi simulace bude mapa kaustik uložena ve třídě \verb|State| jako \verb|m_CausticMap|.
            
        \subsection{Třída SceneRenderer}
        
            Konečná fáze simulace bude vykreslení finální scény. Reflekce a refrakce budou zde též implementované, neboť pro jejich vykreslení bude  třeba stejných algoritmů jako pro vykreslení finální scény. 
            
            Refrakce a reflekce jsem se rozhodl implementovat pomocí Shahova odhadu průsečíků \cite{Shah2007}. Po vypočtení průsečíku lomeného, resp. odrazeného, paprsku s\;geometrií scény v prostoru obrazu převedu souřadnice průsečíku do souřadnicového systému textur. V případě, že převedené souřadnice textury nebudou ležet v\;prostoru obrazovky, budu vzorkovat barvu pro daný paprsek podle textury prostředí uložené ve formátu \emph{cubemapy}. V případě, že bude ležet v prostoru obrazovky, budu vzorkovat barvu z obrazu scény.
            
            Útlum světla pod vodní hladinou budu implementovat podle vzdálenosti daného vrcholu od klidové hladiny vody. Podle vzdálenosti budu měnit barvu světla podle předem nastavených barev. Blízko hladiny nebude barva světla téměř modifikována, zatímco v hlubších prostorech vody  bude barva postupně přecházet na tmavě modrou. 
            
            Nakonec lze vykreslit finální scénu. Všechny předešlé fáze a operace se následně budou neustále opakovat ve vykreslovací smyčce.
            
            
\chapter{Implementace aplikace}
    Tato kapitola se zaobírá implementací simulátoru vodního útvaru. Protože aplikační část řídí jen nepodstatné části celého programu (zobrazení finální scény, zpracování vstupu nebo předávání instrukcí grafické kartě), bude hlavním obsahem implementace \emph{shader} programů, které v realitě provádí všechny podstatné operace algoritmů simulace.
    
    \section{Simulace hladiny podle vlnové rovnice}
        Simulace hladiny podle vlnové rovnice spočívá v transformaci výšek jednotlivých bodů roviny. Samozřejmě je možné simulátoru rovinu dodat jako model (ve formátu \verb|.obj|), lze ale také její geometrii procedulárně vygenerovat, což umožňuje větší kontrolu nad detailnosti vodní plochy zvyšováním rozlišení roviny (počtu vrcholů podél strany roviny). Třída \verb|PlaneGenerator| takovou rovinu generuje, geometrie roviny je generátorem normalizovaná, tj. souřadnice jeho vrcholů jsou škálovány do intervalu $[-1,1]$, dále vypočítá vrcholům jejich příslušnou texturovací souřadnici, které budou v simulaci důležitým vstupem. 
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{c++}
void PlaneGenerator::Generate(const int & res,
    std::vector<Vertex> & vert, std::vector<unsigned int> & ind)
        \end{minted}
        
        Metoda \verb|Generate| podle rozlišení \verb|res|, tj. počet vrcholů podél strany roviny, generuje vrcholy roviny, které uloží do pole \verb|vert|, indexy vrcholů tvořící trojúhelníky, které jsou potřeba pro vykreslení roviny grafickým API OpenGL, jsou dále uloženy v poli \verb|ind|. Výsledná rovina je znázorněna v obrázku \ref{fig:plane}.        
        
        \begin{figure}\centering
            \includegraphics[width=0.5\textwidth]{img/plane}
            \caption{Geometrie vygenerované roviny. \cite{Heightfield2022}}
            \label{fig:plane}
        \end{figure}
        
        Jak bylo v předešlých kapitolách zmíněno pro implementaci výpočtu simulace hladiny podle vlnové rovnice je třeba v polích \verb|u[i,j]| a \verb|v[i,j]| průběžně ukládat výšky roviny a rychlosti změn výšek v daných bodech roviny. Bohužel pole nelze jednoduše předávat mezi pamětí aplikace a pamětí grafické karty. Řešením je použití textur. Jednotlivé pixely textury následně reprezentují jednu buňku pole. Protože textury pracují v kanálech RGB, lze zakomponovat pole \verb|u[i,j]| a \verb|v[i,j]| do jedné textury. Výšky budou uloženy v kanálu červené barvy, zatímco rychlost bude uložena v\;kanálu zelené barvy. Dále je dobré zmínit, že textury obvykle pracují s nezápornými desetinnými hodnotami. Výpočty vlnové rovnice se ale mohou pohybovat v záporných hodnotách. Pro nastavení použití i těchto hodnot je třeba vygenerovat texturu s\;parametrem \verb|RGBA32F| místo \verb|RGBA|,
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{c++}
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, m_Width, m_Height, 0,
             GL_RGB, GL_FLOAT, 0).
        \end{minted}

        Vzorkování mimo rozsah textury je nastaveno, jak Müller navrhoval, opakování hraničních hodnot nastavením parametru \verb|GL_CLAMP_TO_EDGE|
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{c++}
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
                GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
                GL_CLAMP_TO_EDGE).
        \end{minted}

        Další překážkou je, že do textur nelze přistupovat a zároveň zapisovat, a proto je třeba vytvořit dvě textury simulace hladiny a během simulace mezi nimi prohazovat tzv. metodou ping-pongování. Nechť první textura je označena \verb|T_1| a druhá \verb|T_2|. Ping-pongování textury funguje následujícím způsobem, při prvním průchod \verb|i=0| vykreslovací smyčky bude simulátoru hladiny přiřazena textura \verb|T_1| jako vstupní parametr, z kterých vypočte stav vodní hladiny do dalšího průchodu smyčky, výsledek výpočtu následně uloží do textury \verb|T_2|. V dalším průchodu smyčky \verb|i=1| se prohodí textury \verb|T_1| a \verb|T_2|. Nyní bude textura \verb|T_2| vstupem simulátoru a \verb|T_1| odchozí texturou. Tento proces se neustále opakuje.
        \newpage
        Výpočet vlnové rovnice je znázorněn tímto kódem \emph{fragment shaderu}
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
void main()
{
    if (abort) {
        FragColor = vec4(vec3(0.0), 1.0);
        return;
    }

    vec4 old_info = texture(heightField, fTexCoord);
    
    ...
    
    float vpdx = texture(heightField, pdx).r + AddDrop(pdx);
    float vndx = texture(heightField, ndx).r + AddDrop(ndx);
    float vpdy = texture(heightField, pdy).r + AddDrop(pdy);
    float vndy = texture(heightField, ndy).r + AddDrop(ndy);

    float nsum = vpdx + vndx + vpdy + vndy;
    float average =  (vpdx + vndx + vpdy + vndy) / 4.0;
    float h = texelSize;
    float old_u = old_info.r + AddDrop(fTexCoord);
    float old_v = old_info.g;

    float offset = average - old_u;
    float maxslope = waveSlope;
    float maxoffset = maxslope * h;

    if (offset > maxoffset) 
        old_u = old_u + offset - maxoffset;
    if (offset < -maxoffset)
        old_u = old_u + offset + maxoffset;
    
    float c = max(waveSpeed, 0.001f);
    float f = c * c * (nsum - 4 * old_u) / (h * h);
    float new_v = old_v + f * deltaTime;
    new_v = new_v - old_u;
    new_v = max((1 - waveDamping), 0.001f) * new_v;
    float new_u = old_u + new_v * deltaTime; 
    new_u = new_u;
    
    vec4 new_info = vec4(new_u , new_v, 0, 1);
    FragColor = new_info;
}.
        \end{minted}

        Hodnota \verb|abort| je pravdivá v případě, že bylo nařízeno vynulovat textury výškové mapy, a tím pádem i resetovat hladinu do klidového stavu. Funkce \verb|AddDrop| provádí deformaci hladiny uživatelem, která připíše podle dané pozice výšku okolním bodům podle tvaru sinusoidy. Funkce mění výšku také podle zadané amplitudy \verb|amplitude|, která udává maximální přidanou výšku, a poloměru rozsahu působení \verb|radius|. 
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
float AddDrop(vec2 pos)
{
    if (!drop)
        return 0.0;
    float r = max(radius, 0.001f)  * texelSize;
    float val = max(0.0, 1.0 - length(dropPos - pos) / r);
    val = 0.5 - cos(val * PI) * 0.5;
    return amplitude * val;
}         
        \end{minted}

        Müllerův uvedený algoritmus \cite{Mueller2008}, ale posouvá výšku  klidové roviny ve směru deformace. Jestli se za hladinu \uv{zatáhne} nahoru, posune se celá hladina nahoru, což ale v realitě není možné. Wallace \cite{Wallace2022} řeší tento problém úpravou rychlosti výškou tak, aby změněná výška konvergovala k výšce klidové hladiny
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
new_v = new_v - old_u.
        \end{minted}
        
        Zbylý program je dále podle Müllerova algoritmu \cite{Mueller2008} zmíněný v analýze metody podle vlnové rovnice. Deformovaná rovina, tj. vodní hladina, je následně zobrazena podle \emph{vertex shaderu}, který na vstupu přijímá texturu výškové mapy a podle její texturovací souřadnice přičte k výšce vrcholu hodnotu textury uložené v červeném kanálu
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
float height = texture(heightField, aTexCoord).r;
vec3 offset = vec3(0.0f, height, 0.0f);

vec4 worldCoord = model * vec4(aPosition + offset, 1.0f).
        \end{minted}

    \section{Simulace kaustik}
        Shahova formace kaustik \cite{Shah2007} předpokládá na vstupu tři podpůrné textury. Jedna obsahuje souřadnice a druhá normály interpolovaných vrcholů vodního povrchu ve světovém souřadnicovém systému z pohledu světla, tzn. RGB barva objektu v textuře bude XYZ souřadnice pozice nebo normály. 
        
         \begin{figure}\centering
            \includegraphics[width=0.5\textwidth]{img/positions}
            \caption{Textura souřadnic interpolovaných vrcholů modelů scény z pohledu kamery.}
            \label{fig:positionstex}
        \end{figure}
        
        Normály hladiny, ale nemáme ihned k dispozici, neboť máme jen informace o výšce jednotlivých bodů roviny uložené ve výškové mapě. Naštěstí lze její hodnotu z výškové mapy vypočítat jako vektorový součin horizontálních a vertikálních rozdílů výšek.  Nechť $M$ je vrchol, pro který počítáme normálu, a $t$, $b$, $l$ a $r$ jsou výšky horního, dolního, levého a pravého sousedního vrcholu $M$. Normála vrcholu $M$ je poté rovna hodnotě $n$ \cite{Normal2022}
        
        \begin{equation}
            \begin{split}
            v &= (2, r - l, 0), \\
            h &= (0, t - b, 2), \\ 
            n &= v \times h. 
            \end{split}
        \end{equation}

        \noindent Dále bude třeba vyrenderovat pozice objektů ve světovém souřadnicovém systému, na které se kaustiky mohou promítnout.

        Kromě textur je třeba vygenerovat mřížku podobné v obrázku \ref{fig:plane}. Na rozdíl od mřížky používané v simulaci vodní hladiny je tato mřížka bez jakýkoliv hran, které vrcholy spojují. Ve výsledku má mřížka podobu rovnoměrně rozložených vrcholů. Třída \verb|PlaneGenerator| pro výpočet kaustik umí vygenerovat požadovanou mřížku ve zvoleném rozlišení.
        
        \emph{Vertex shader}, který provádí většinu výpočtu kaustik, poté přijímá podpůrné textury zmíněné výše a mřížku, která má stejné rozlišení jako podpůrné textury, a to aby jednotlivým bodům  mřížky odpovídal právě jeden texel textury. Celý výpočet se řídí podle tohoto kódu
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
void main()
{
    vec4 refractivePosition = texture(refractivePositions, aTexCoord);
    vec4 refractiveNormal = texture(refractiveNormals, aTexCoord);
    vec3 incidentLight = normalize(light.dir);
    vec3 refractedLight  = normalize(refract(incidentLight,
                                     normalize(refractiveNormal.xyz), ETA));
    vec4 p = EstimateIntersection(refractivePosition.xyz, refractedLight);
    if (refractivePosition.a <= 0.001f || 
        refractiveNormal.a <= 0.001f || 
        p.a <= 0.001f ||
        p.y > refractivePosition.y || 
        dot(p.xyz - refractivePosition.xyz, refractedLight) < 0.01f)
        fValid = 0;
    else
        fValid = 1;

    fDistance = distance(p, refractivePosition);
    fPhi = dot(-incidentLight, normalize(refractiveNormal.xyz));
    gl_Position = projection * view * model * vec4(p.xyz, 1.0);
}.   
        \end{minted}

        Algoritmus funguje takovým způsobem, že prochází všemi body mřížky, a jestli danému bodu odpovídá nějaký validní texel z textury pozic refraktujícího objektu, tj. vodní hladiny, odhadne podle funkce \verb|EstimateIntersection| používající postup navržený Shahem  souřadnice průsečíku pomocí textury pozic přijímacích objektů. 
        
        Následuje kontrola validity průsečíku. Nejprve se kontroluje, jestli vrcholu mřížky odpovídá vůbec nějaký vrchol vodní hladiny, dále jestli odhadovaný průsečík vůbec existuje a nakonec jestli neleží odhadovaný průsečík nad hladinou vody.
        
        Výraznost kaustiky je pak určena podle počtu vrcholů, které se promítnou na stejné místo. OpenGL ale standardně překrývá fragmenty na stejných pozicích, a proto by se intenzita kaustik nezvyšovala s vyšší počtem vrcholů se stejným průsečíkem. Pro dosažení tohoto efektu je třeba povolit OpenGL míchání barev funkcemi
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{c++}
            glEnable(GL_BLEND);
            glBlendFunc(GL_ONE, GL_ONE).
        \end{minted}
        
        Funkce \verb|glBlendFund(GL_ONE, GL_ONE)| nastavuje způsob míchání barev tak, aby se po vyslání fragmentu pro vykreslení barva sečetla s barvou, která leží na stejné pozici jako vyslaný fragment. Intenzita kaustik je dále ve \emph{fragment shaderu} tlumena vzdáleností \verb|fDistance|, kterou promítnutý vrchol cestoval, a úhlem dopadu světla \verb|fPhi|. 

        Objekty nakonec vzorkují mapu kaustik texturovacími souřadnicemi spočítané transformací světových souřadnic vrcholů do souřadnicové systému obrazu světla
        
         \newpage
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
vec2 calculateCausticsTexCoord()
{
    vec4 lightClip = orthogonal *
                     lightView *
                     model * vec4(aPosition, 1.0);
    vec2 texC = 0.5 * (lightClip.xy/lightClip.w) + 0.5;
    return texC;
}.
        \end{minted}
        
        Shah dále doporučuje rozmazání mapy kaustik \cite{Shah2007}, aby nešly vidět artefakty způsobené promítáním konečného počtu vrcholů. Použití obyčejného rozmazání se z mapy kaustik ztrácí vysoké frekvence, které jsou  nejvíce vizuálně atraktivní, a proto provádím rozmazání konvolucí s Gaussovo jádrem.   

         \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/causticmap}
            \caption{Nefiltrovaná mapa kaustik.}
        \end{figure}
        
         \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/causticmapfiltered}
            \caption{Mapa kaustik filtrovaná Gaussovým rozmazáním.}
        \end{figure}
    \section{Simulace reflekcí a refrakcí}

        Reflekce a refrakce jsou implementované obdobně jako formace kaustik. Po vyslání pohledové paprsku a jeho transformaci na lomený, resp. odražený, paprsek se spočítá jeho odhadovaný průsečík pomocí textury pozic interpolovaných vrcholů objektů, od kterých se může obraz refraktovat, resp. odrazit. Odhad je stejně implementován jako u kaustik s výjimkou délky prvního odhadu, který je škálován podle úhlu pohledu
        
        \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
vec2 EstimateIntersection(vec3 v,
                          vec3 r,
                          vec3 normal,
                          sampler2D positions)
{
    vec3 p1 = v + firstGuess * (1 - dot(normal, normalize(toCameraDir))) * r; 
    vec4 texPt = projection * view * vec4(p1, 1.0);
    vec2 texC = 0.5 * (texPt.xy/texPt.w) + 0.5;
    vec4 recPos = texture(positions, texC);
    if (recPos.a <= 0.0f)
        return vec2(-1.0f);
    float d = distance(v, recPos.xyz);
    vec3 p2 = v + d * r;
    texPt = projection * view * vec4(p2, 1.0);
    texC = 0.5 * (texPt.xy/texPt.w) + 0.5;
    if (texC.x < 0 || texC.x > 1 || texC.y < 0 || texC.y > 1)
        return vec2(-1.0f);
    return texC;
}.
         \end{minted}
    Hodnota \verb|v| zde značí bod, od kterého se lomený, resp. odražený, paprsek \verb|r| pohybuje dále. 
    
    Jestli hledaný průsečík neexistuje nebo texturovací souřadnice jsou mimo obraz displeje, vzorkují se reflekce a refrakce podle textury prostředí uložené v \emph{cubemapě}. 
    
    Po získání texturovacích souřadnic se vzorkuje barva reflekcí a refrakcí podle pomocných textur, ve kterých je uložena scéna. Pro refrakce pomocná textura obsahuje vykreslené objekty, které leží pod hladinou vody, neboť  refrakce zkreslují jen, co je pod její hladinou. U reflekcí jsou to naopak jen objekty, které leží nad hladinou.  
    
    \newpage
        
    \section{Simulace útlumu světla}
    
    Útlum světla je naivně implementován podle vzdálenosti objektů od hladiny vody. Podle vzdálenosti dále postupně přechází barva světla podle předem definovaných barev
    
    \begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]{glsl}
vec3 n = vec3(1.0f);
vec3 f = firstStageColor;
vec3 s = secondStageColor;
vec3 t = finalStageColor;

if (diff <= 0)
    lightColor = n;
else if (diff <= firstStage)
    lightColor = 
      mix(n, f, (diff - 0.0f)/(firstStage - 0.0f));
else if (diff <= secondStage)
    lightColor = 
      mix(f, s, (diff - firstStage)/(secondStage - firstStage));
else
    lightColor =
      mix(s, t, (diff - secondStage)/(3.0f - secondStage));

...

float a = attenuation;
float I = exp(-a * clamp(diff, 0, diff)).
    \end{minted}

\chapter{Výsledky implementace}
    
    Následující kapitola je zaměřena na ukázku konečných vizuálních výsledků implementace. Mimo vykreslených scén jsou zde probrány nedostatky zvolených algoritmů.
   
    Největších chyb vzniká při aproximací velmi citlivých výpočtů jako refrakce a reflekce viditelné v obrázcích \ref{fig:rrerr1}, \ref{fig:rrerr2}, \ref{fig:rrerr3} \ref{fig:duckr}.
    
    V obrázku \ref{fig:rrerr1} dochází k tomu, že odhadovaný průsečík vychází z prostoru obrazu a následně místo textury scény vzorkuje z textury prostředí v \emph{cubemapě}. V obrázku \ref{fig:rrerr2} dochází k tomu, že vyslaný lomený prvek protne scénu ale ve špatném místě, protože reálný průsečík je z pohledu kamery schovaný za nějakou geometrií, která leží před ním. V \ref{fig:rrerr3} lze vidět chybu míchání barev odražené a refraktované scény podle Fresnelových ronvic způsobena nepřesností aproximací průsečíků. Odraz kachničky v obrázku \ref{fig:duckr} má siluetu samotné kachničky kvůli způsobu odhadu průsečíku, který ověřuje jeho správnost pomocí textury pozic reflektovaných objektů (zde kachničky). 
    
    Tyto nedostatky jsou nejvíce výrazné při pohledu zblízka a rovné vodní hladině. Naštěstí se v realitě vodní hladina neustále hýbe a díky zkreslení obrazu refrakcemi jsou tyto chyby zamaskovány. Korektnost výpočtu průsečíku spočívá ve správném odhadu délky lomeného, resp. odraženého,  paprsku. V aplikaci testovací scény lze tento parametr měnit v sekci \emph{Reflections/refractions settings} parameter \emph{First guess}.

    Další vizuální artefakty mohou nastat při volbě silné intenzity kaustik (viz obrázek \ref{fig:causticerr}), které jsou způsobené  Shahovou metodou \cite{Shah2007}, která promítá jen konečný počet paprsků (vrcholů) skrz vodní hladinu.
    
    Kromě optických chyb jsem narazil i na podstatný nedostatek v integraci vlnové rovnice. Müllerova metoda předpokládá, že časový krok integrace $\Delta t$ je konstantní v průběhu celé simulace \cite{Mueller2008}. V případě že, rychlost výpočtu vlnové rovnice je nad $\mathtt{\sim}100$ FPS, simulace zůstává stabilní, ale při $\mathtt{\sim}40$ FPS může jakýkoliv výkyv rychlosti porušit stabilitu simulace a přivést chybu do výpočtu, která se může později projevit.  
    
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr1}
        \caption{Chyba refrakcí způsobena špatným odhadem průsečíku a restrikcí odhadu na prostor obrazu.}
        \label{fig:rrerr1}
    \end{figure}
    
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr2}
        \caption{Chyba refrakcí způsobena schovaným průsečíkem za cizí geometrií.}
        \label{fig:rrerr2}
    \end{figure}
    
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/rrerr3}
        \caption{Chyba refrakcí a reflekcí způsobena nepřesností odhadu průsečíku.}
        \label{fig:rrerr3}
    \end{figure}
    
    
     \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/duckreflection}
        \caption{Odraz kachničky a chyba způsobena texturovací souřadnicí průsečíku ležící mimo obraz scény.}
     \label{fig:duckr}
    \end{figure}
    
    \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/heightfield}
            \caption{Testovací scéna se simulátorem vodního útvaru.}
    \end{figure}
    
    \begin{figure}\centering
            \includegraphics[width=0.75\textwidth]{img/normal}
            \caption{Testovací scéna s viditelnými kaustikami.}
    \end{figure}
        
    \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/caustics}
        \caption{Formace kaustik na podvodních objektech.}
    \end{figure}
    
     \begin{figure}\centering
        \includegraphics[width=0.75\textwidth]{img/causticserror}
        \caption{Artefakty mapy kaustik způsobené promítáním konečného počtu vrcholů (paprsků).}
        \label{fig:causticerr}
    \end{figure}
    
    
    
    
    
